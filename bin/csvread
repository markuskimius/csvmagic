#!/usr/bin/env python3
"""A command line utility to display csv rows in a more human-readable format.

https://github.com/markuskimius/csvread
"""

import sys, os, errno, re, argparse, importlib

__copyright__ = "Copyright 2018-2019, Mark Kim"
__license__ = "Apache 2.0"

def main():
    global opts
    CSV_LIBRARY_PATH = os.getenv("CSV_LIBRARY_PATH") or ""

    # Set up the library search path
    for path in CSV_LIBRARY_PATH.split(":"):
        sys.path.append(path)

    # Parse arguments
    parser = argparse.ArgumentParser(
        description="Display csv rows in a more readable format.",
        epilog="To use libraries without specifying its full path as a part of the command, "
        "set the CSV_LIBRARY_PATH environment variable.")
    parser.add_argument("files", metavar="FILE", nargs="*", help="csv file(s) to read.")
    parser.add_argument("-n", "--no-header", dest="has_header", default=True, action="store_false", help="File has no header; use column number as header.")
    parser.add_argument("-s", "--strip-quotes", dest="strip_quotes", default=False, action="store_true", help="Strip quotes around each field.")
    parser.add_argument("-d", "--delim", dest="delim", default=",", help="Use DELIM instead of comma to delimit values. May be 'p' for pipe, 't' for tab, and 'a' for SOH.")
    parser.add_argument("-l", "--lib", dest="lib", default="", help="Use LIB to preprocess headers and/or values before display.")
    parser.add_argument("-p", "--path", dest="path", default="", help="Plugin library search path.")
    opts = parser.parse_args()

    # Delimiters may use shorthands
    if opts.delim in ('p'):
        opts.delim = '|'
    elif opts.delim in ('t'):
        opts.delim = '\t'
    elif opts.delim in ('a'):
        opts.delim = '\u0001'

    # Delimiter may contain escape characters
    opts.delim = bytes(opts.delim, "utf-8").decode("unicode_escape")

    # Regex to match fields and rows
    unquoted_field_re = r'[^%s"]*' % opts.delim
    quoted_field_re = r'"(?:[^"]|"")*"'
    field_re = r'(?:%s)|(?:%s)' % (unquoted_field_re, quoted_field_re)
    row_re = r'(?:%s)(?:%s(?:%s))*' % (field_re, re.escape(opts.delim), field_re)
    opts.match_field = re.compile(r'^(%s)$' % field_re)
    opts.match_row = re.compile(r'^(%s)$' % row_re)
    opts.match_quoted_field = re.compile(r'^"(.*)"$')

    opts.norm_fn = def_norm_fn
    opts.name_fn = def_name_fn
    opts.val_fn = def_val_fn

    if(len(opts.path)): sys.path.insert(0, opts.path)
    if(len(opts.lib)): load_lib(opts.lib)

    # Read from STDIN if no file specified
    if(len(opts.files) == 0):
        opts.files.append("-")

    # Read each file
    for f in opts.files:
        read_csv(f)

def def_norm_fn(name, value):
    return (name, value)

def def_name_fn(name, value):
    return name

def def_val_fn(name, value):
    return value

def load_lib(path):
    global opts
    folder = os.path.dirname(opts.lib)
    file = os.path.basename(opts.lib)

    # The library is imported from the system path; so we add the library
    # folder to the system path, load the library, then restore the path.
    if(len(folder)): sys.path.insert(0, folder)
    lib = importlib.import_module(file)
    if(len(folder)): sys.path.pop(0)

    # Load the methods from the library
    if("normalize" in dir(lib)): opts.norm_fn = lib.normalize
    if("get_name" in dir(lib)): opts.name_fn = lib.get_name
    if("get_value" in dir(lib)): opts.val_fn = lib.get_value

def read_csv(file):
    global opts

    try:
        fd = sys.stdin if(file == "-") else open(file, "rt")
    except IOError as e:
        print(e, file=sys.stderr)
        sys.exit(1)

    header = read_header(fd) if(opts.has_header) else []
    read_body(fd, header)

    if(file != "-"):
        fd.close()

def read_header(fd):
    global opts

    # Get the header
    line = read_row(fd)
    if(line == ""):
        print("%s: No data" % fd.name)
        sys.exit(1)

    header = split(chomp(line))

    return header

def read_body(fd, header):
    global opts

    line = read_row(fd)
    while(line != ""):
        width = 0
        names = []
        values = []

        line = chomp(line)
        fields = split(line)
        if(line == ""):
            line = fd.readline()
            continue

        # Fields
        for i in range(max(len(header), len(fields))):
            name = header[i] if(i < len(header)) else ""
            value = fields[i] if(i < len(fields)) else ""
            if(name == "" and value == ""): continue

            # Transform names and values using the translation library
            name, value = opts.norm_fn(name, value)
            new_name = opts.name_fn(name, value)
            new_value = opts.val_fn(name, value)

            # Use column # as the header if it's blank
            if(new_name == "" and opts.has_header == False): new_name = str(i+1)

            names.append(new_name)
            values.append(new_value)
            width = max(width, len(new_name))

        # Display
        for i in range(len(values)):
            name = names[i]
            value = values[i]
            print("%-*s : %s" % (width, name, value))

        # Next!
        print("")
        line = read_row(fd)

def read_row(fd):
    global opts
    row_re = opts.match_row
    line = ""

    while(True):
        next = fd.readline()

        # Break on EOF
        if(next == ""): break

        line += next

        # Break on valid row
        if(row_re.match(line)): break

    return line

def chomp(line):
    return line.rstrip('\n')

def split(line):
    global opts
    field_re = opts.match_field
    quoted_field_re = opts.match_quoted_field
    delim = opts.delim

    rawfields = line.split(delim)
    fields = []
    last = ""

    # Join fields containing delimiters
    for f in rawfields:
        if len(last):
            last += delim + f

            if(field_re.match(last)):
                fields.append(last)
                last = ""
        elif field_re.match(f):
            fields.append(f)
        else:
            last = f

    # Clean up
    if len(last):
        fields.append(last)

    # Strip quotes if requested
    if opts.strip_quotes:
        fields = list(map(lambda x: quoted_field_re.sub(r'\1', x), fields))

    return fields

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("")
        sys.exit(errno.EOWNERDEAD)

# vim:ft=python
