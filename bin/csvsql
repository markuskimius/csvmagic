#!/bin/sh

##############################################################################
# SQL query csv file(s).
#

##############################################################################
# BOOTSTRAP
#
# Include ../lib in the search path before calling python.
# (Thanks to https://unix.stackexchange.com/questions/20880)
#
if "true" : '''\'
then
    export PYTHONPATH="$(dirname $0)/../lib:$PYTHONPATH"
    pythoncmd=python

    if command -v python3 >/dev/null; then
        pythoncmd=python3
    fi

    exec "$pythoncmd" "$0" "$@"
    exit 127
fi
'''

##############################################################################
# PYTHON CODE BEGINS HERE

import os
import re
import sys
import errno
import shlex
import libcsv
import getopts
import sqlite3
import readline
import subprocess

__copyright__ = 'Copyright 2020 Mark Kim'
__license__ = 'Apache 2.0'


##############################################################################
# GLOBALS

SCRIPTNAME = os.path.basename(__file__)

class opts:
    files = []
    delim = None
    commands = []


##############################################################################
# USAGE

def usage():
    '''\
SQL query csv file(s).

usage: {SCRIPTNAME} [OPTIONS] [FILES]

Options:
  FILE                  csv file(s) to query.

  -c, --command=SQL     SQL commands to execute.  May be specified multiple
                        times, once per SQL command.

  -d, --delim=DELIM     Use DELIM as the value delimiter, where DELIM may be
                        'p' for the pipe (|), 't' for the tab (\\t), 'a' for
                        the SOH (ASCII 1), or other string literal of one or
                        more characters and Python  string  escape  sequences.
                        DELIM  may  include  escape characters.  By default the
                        delimiter is guessed from the characters in the
                        CSV_DELIMS environment variable.

Environment Variables:
  CSV_DELIMS            A set of characters used to guess the delimiter of a
                        csv file.  The guesswork happens when reading  the
                        first  line  of  the first FILE, by testing each
                        character present in CSV_DELIMS for the character with
                        the most occurrence in the line.  If any of the
                        characters occur the same number  of  times  (including
                        zero),  the  earlier  character  in the variable is
                        chosen.  If the environment variable is not set, it
                        defaults to '{libcsv.DELIMS}'.  CSV_DELIMS may include
                        escape characters.

'''

    print(usage.__doc__.format(**globals()))


##############################################################################
# MAIN

def main():
    errcount = 0

    getopt = getopts.getopts(sys.argv, {
        'c' : 1, 'command' : 1,
        'd' : 1, 'delim'   : 1,
        'h' : 0, 'help'    : 0,
    })

    for c in getopt:
        if c in ('-')                   : opts.files.append(getopt.optarg)
        elif c in ('c', 'command')      : opts.commands.append(getopt.optarg)
        elif c in ('d', 'delim')        : opts.delim = arg_to_delim(getopt.optarg)
        elif c in ('h', 'help')         : usage(); sys.exit(0)
        else                            : errcount += 1

    # Sanity check
    if errcount:
        sys.stderr.write('Type `{SCRIPTNAME} --help` for help.\n'.format(**globals()))
        sys.exit(1)

    # Instantiate the database
    db = Database()

    # Load all tables
    for f in opts.files:
        db.load(f)

    # Execute SQL commands
    for c in opts.commands:
        db.execute(c)

    # If no commands were specified, launch the CLI
    if not opts.commands:
        CLI(db).mainloop()


def arg_to_delim(delim):
    # Delimiter shorthands
    if delim in ('p'): delim = '|'
    elif delim in ('t'): delim = '\t'
    elif delim in ('a'): delim = '\u0001'

    # Translate escape characters
    decoded = delim.encode().decode('unicode_escape')

    # Use the decoded string only if it's a single character
    if len(delim) == 1 or len(decoded) == 1:
        delim = decoded

    return delim


class CLI(object):
    __PROMPT = 'csvsql> '

    def __init__(self, database):
        self.__db = database
        self.__commands = {
            'echo': {
                'args': '[ARGS]',
                'desc': 'Print ARGS to stdout.',
                'exec': self.__cmd_echo,
            },

            'load': {
                'args': 'FILE [--as=TABLE] [--delim=DELIM]',
                'desc': 'Load FILE into TABLE.  If omitted TABLE is the filename without the extension.',
                'exec': self.__cmd_load,
            },

            'showtables': {
                'desc': 'Print the list of tables.',
                'exec': self.__cmd_showtables,
            },

            '!': {
                'args': 'COMMAND [ARGS]',
                'desc': 'Execute the program COMMAND and pass ARGS.',
                'exec': self.__cmd_exec,
            },

            'help': {
                'desc': 'Show the list of commands.',
                'exec': self.__cmd_help,
            },
        }

    def mainloop(self):
        while True:
            try:
                line = self.__getcommand()
                self.__runcommand(line)

            except EOFError as e:
                print('')
                break

            except AttributeError as e:
                pass

    def __getcommand(self):
        prompt = self.__PROMPT
        line = ''

        while True:
            line += input(self.__PROMPT)

            # Test for the line continuation character
            if line.endswith('\\'):
                line = line[:-1]
                continue

            # Test for parsability
            try:
                shlex.shlex(line, posix=True, punctuation_chars=True)
            except ValueError:
                line += '\n'
                continue

            # Done!
            break

        return line

    def __runcommand(self, line):
        parts = shlex.shlex(line, posix=True, punctuation_chars=True)
        parts = list(parts)

        command = parts[0].lower() if len(parts) else None
        args = parts[1:]

        if command is None:
            pass
        elif command in self.__commands:
            self.__commands[command]['exec'](args)
        else:
            self.__db.execute(line)

    def __cmd_echo(self, args):
        print(args)

    def __cmd_exit(self, args):
        raise EOFError()

    def __cmd_help(self, args):
        commands = self.__commands

        print('')

        for cmd in args or sorted(commands.keys()):
            SYNTAX_WIDTH = 17

            if cmd in commands:
                command = commands[cmd]
                help_args = command['args'] if 'args' in command else ''
                help_desc = command['desc']
                syntax = '%s %s' % (cmd, help_args)

                if len(syntax) <= SYNTAX_WIDTH:
                    print('    %-*s %s' % (SYNTAX_WIDTH, syntax, help_desc))
                else:
                    print('    %-*s' % (SYNTAX_WIDTH, syntax))
                    print('    %-*s %s' % (SYNTAX_WIDTH, '', help_desc))

            else:
                print('No help for: %s' % cmd)

        print('')

    def __cmd_load(self, args):
        filenames = []
        tablenames = []
        delim = None
        exitcode = 0

        getopt = getopts.getopts(['read'] + args, {
            'a' : 1, 'as'    : 1,
            'd' : 1, 'delim' : 1,
        })

        for c in getopt:
            if c in ('-')            : filenames.append(getopt.optarg)
            elif c in ('a', 'as')    : tablename.append(getopt.optarg)
            elif c in ('d', 'delim') : delim = getopt.optarg
            else                     : exitcode = 1

            while len(tablenames) < len(filenames)-1:
                tablenames.append(None)

            while len(filenames) < len(tablenames)-1:
                filenames.append(None)

        while len(filenames) < len(tablenames):
            filenames.append(None)

        while len(tablenames) < len(filenames):
            tablenames.append(None)

        if exitcode == 0:
            for i, f in enumerate(filenames):
                t = tablenames[i]

                self.__db.load(f, t, delim)

        return exitcode

    def __cmd_showtables(self, args):
        tablelist = {}
        widths = [0, 0]

        for trow in self.__db.query("select name from sqlite_master where type='table'"):
            table = trow[0]

            for crow in self.__db.query("select count(*) from %s" % table):
                count = crow[0]

            widths[0] = max(widths[0], len(table))
            widths[1] = max(widths[1], len(str(count)))

            tablelist[table] = {
                'count': count,
            }

        for table in sorted(tablelist.keys()):
            count = tablelist[table]['count']

            print("%-*s  %-*s records" % (widths[0], table, widths[1], count))

        print('')

    def __cmd_exec(self, args):
        try:
            process = subprocess.Popen(args)
            process.wait()
        except IndexError as e:
            print('Must specify a command')
        except FileNotFoundError as e:
            print(str(e))

        print()


class Database(object):
    def __init__(self, delim=','):
        self.__conn = sqlite3.connect('')
        self.__tablenames = []
        self.__delim = delim

    def load(self, filename, tablename=None, delim=None):
        is_loaded = True

        if tablename is None:
            tablename = os.path.basename(filename)
            tablename = os.path.splitext(tablename)[0]

        with smart_open(filename) as file:
            reader = libcsv.Reader(file, delim=delim, has_header=True, is_multitable=False)
            insert_count = 0

            for row in reader:
                if len(row):
                    insert_count += self.insert(tablename, row)

            if insert_count > 0:
                is_loaded = True

        return is_loaded

    def insert(self, tablename, row):
        qs = self.__delim.join(['?'] * len(row))
        table_exists = tablename in self.__tablenames
        query_result = None
        insert_count = 0

        # Create the table if it does not exist
        if not table_exists:
            if self.create(tablename, row.header().as_list()):
                self.__tablenames.append(tablename)
                table_exists = True

        if table_exists:
            query_result = self.query('insert into %s values (%s)' % (tablename, qs), *row.as_stripped_list())

        if query_result:
            insert_count = query_result.rowcount

        return insert_count

    def create(self, tablenames, fieldnames):
        is_created = False

        fieldnames = map(lambda x: self.__quote(x), fieldnames)

        if self.query('create table %s (%s)' % (tablenames, self.__delim.join(fieldnames))):
            is_created = True

        return is_created

    def __quote(self, string):
        string = string.replace("'", "''")

        return "'%s'" % string

    def query(self, command, *args):
        result = None

        try:
            result = self.__conn.cursor().execute(command, args)
        except sqlite3.OperationalError as e:
            sys.stderr.write('%s %s -- %s\n\n' % (command, args, str(e)))

        return result

    def execute(self, command, *args):
        delim = self.__delim
        count = 0

        try:
            cursor = self.query(command, *args)
            if cursor is None: return

            # Execute the command and print any rows it returns
            for i, row in enumerate(cursor):
                values = []

                # Print column names
                if i == 0:
                    cols = []

                    for j, cell in enumerate(cursor.description):
                        cols.append(libcsv.Value(cell[0]).minquoted(delim))

                    print(delim.join(cols))

                # Print row values
                for j, cell in enumerate(row):
                    v = libcsv.Value(cell).strquoted(delim)

                    if v == '':
                        v = 'NULL'

                    values.append(v)

                print(delim.join(values))
                count += 1

            # Empty line after each command that printed something
            if count:
                print('')

        except sqlite3.OperationalError as e:
            sys.stderr.write('%s -- %s\n\n' % (command, str(e)))


def smart_open(filename, mode='r'):
    '''Open a file for reading, treating '-' as a stdin or stdout, depending on
    the mode.'''

    if filename == '-':
        # Duplicate stdin/stdout so the caller can close it without closing stdin.
        fd = sys.stdin.fileno() if 'r' in mode else sys.stdout.fileno()
        fo = os.fdopen(os.dup(fd))
    else:
        fo = open(filename, mode)

    return fo


##############################################################################
# ENTRY POINT

if __name__ == '__main__':
    try:
        main()
    except KeyboardInterrupt:
        print('')
        sys.exit(errno.EOWNERDEAD)


# vim:ft=python
